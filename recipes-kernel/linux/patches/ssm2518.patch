--- a/sound/soc/codecs/ssm2518.c	2016-08-04 11:07:58.177789000 +0200
+++ b/sound/soc/codecs/ssm2518.c	2016-08-16 09:41:44.579186000 +0200
@@ -108,6 +108,10 @@
 #define SSM2518_DAC_FS_64000			0x03
 #define SSM2518_DAC_FS_128000			0x04
 
+/* Debug */
+
+#define DEBUG_SSM2518_SW        0
+
 struct ssm2518 {
 	struct regmap *regmap;
 	bool right_j;
@@ -309,7 +313,7 @@
 	.count = ARRAY_SIZE(ssm2518_rates_12288000),
 };
 
-static unsigned int ssm2518_lookup_mcs(struct ssm2518 *ssm2518,
+static int ssm2518_lookup_mcs(struct ssm2518 *ssm2518,
 	unsigned int rate)
 {
 	const unsigned int *sysclks = NULL;
@@ -343,9 +347,19 @@
 	int mcs;
 	int ret;
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d rate %u\n",__FUNCTION__,__LINE__, rate);
+  #endif
+    
 	mcs = ssm2518_lookup_mcs(ssm2518, rate);
+	
 	if (mcs < 0)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #1 - ssm2518_lookup_mcs(), passed %s %d \n",__FUNCTION__,__LINE__);
+  #endif
 		return mcs;
+	}
 
 	ctrl1_mask = SSM2518_SAI_CTRL1_FS_MASK;
 
@@ -358,9 +372,24 @@
 	else if (rate >= 64000 && rate <= 96000)
 		ctrl1 = SSM2518_SAI_CTRL1_FS_64000_96000;
 	else
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #2, passed %s %d rate invalid\n",__FUNCTION__,__LINE__);
+  #endif
 		return -EINVAL;
+	}
+
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d ctrl1 == %u\n",__FUNCTION__,__LINE__, ctrl1);
+  #endif
+
+	if (ssm2518->right_j)
+	{
+		
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d params_width(params) == %u\n",__FUNCTION__,__LINE__, params_width(params));
+  #endif
 
-	if (ssm2518->right_j) {
 		switch (params_width(params)) {
 		case 16:
 			ctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_16BIT;
@@ -373,17 +402,38 @@
 		}
 		ctrl1_mask |= SSM2518_SAI_CTRL1_FMT_MASK;
 	}
+	
+	
+  
+  
+  
+	
+
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Disable auto samplerate detection, passed %s %d \n",__FUNCTION__,__LINE__);
+  #endif
 
 	/* Disable auto samplerate detection */
 	ret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_CLOCK,
 				SSM2518_CLOCK_ASR, SSM2518_CLOCK_ASR);
+				
 	if (ret < 0)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #4, passed %s %d \n",__FUNCTION__,__LINE__);
+  #endif
 		return ret;
+	}
 
 	ret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL1,
 				ctrl1_mask, ctrl1);
 	if (ret < 0)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #5, passed %s %d \n",__FUNCTION__,__LINE__);
+  #endif
 		return ret;
+	}
 
 	return regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,
 				SSM2518_POWER1_MCS_MASK, mcs << 1);
@@ -394,6 +444,10 @@
 	struct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(dai->codec);
 	unsigned int val;
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Mute %d, passed %s %d \n", mute, __FUNCTION__,__LINE__);
+  #endif
+
 	if (mute)
 		val = SSM2518_MUTE_CTRL_MUTE_MASTER;
 	else
@@ -410,10 +464,17 @@
 	bool invert_fclk;
 	int ret;
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
+
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
 		break;
 	default:
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #1, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return -EINVAL;
 	}
 
@@ -433,6 +494,9 @@
 		invert_fclk = true;
 		break;
 	default:
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #2, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return -EINVAL;
 	}
 
@@ -461,6 +525,9 @@
 		invert_fclk = false;
 		break;
 	default:
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #3, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return -EINVAL;
 	}
 
@@ -468,8 +535,14 @@
 		ctrl2 |= SSM2518_SAI_CTRL2_LRCLK_INVERT;
 
 	ret = regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL1, ctrl1);
+	
 	if (ret)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #4, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return ret;
+	}
 
 	return regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL2, ctrl2);
 }
@@ -495,9 +568,64 @@
 		regcache_sync(ssm2518->regmap);
 	}
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d enable %d \n", __FUNCTION__,__LINE__, enable);
+  #endif
+
 	return ret;
 }
 
+/**
+ * snd_soc_component_get_dapm() - Returns the DAPM context associated with a
+ *  component
+ * @component: The component for which to get the DAPM context
+ */
+
+ static inline struct snd_soc_dapm_context *ssm2518_snd_soc_component_get_dapm(
+         struct snd_soc_component *component)
+{
+         return &component->dapm;
+}
+ 
+/**
+ * snd_soc_codec_get_dapm() - Returns the DAPM context for the CODEC
+ * @codec: The CODEC for which to get the DAPM context
+ *
+ * Note: Use this function instead of directly accessing the CODEC's dapm field
+ */
+
+static inline struct snd_soc_dapm_context *ssm2518_snd_soc_codec_get_dapm(
+        struct snd_soc_codec *codec)
+{
+        return ssm2518_snd_soc_component_get_dapm(&codec->component);
+}
+
+/**
+ * snd_soc_dapm_get_bias_level() - Get current DAPM bias level
+ * @dapm: The context for which to get the bias level
+ *
+ * Returns: The current bias level of the passed DAPM context.
+ */
+
+static inline enum snd_soc_bias_level ssm2518_snd_soc_dapm_get_bias_level(
+	struct snd_soc_dapm_context *dapm)
+{
+	return dapm->bias_level;
+}
+
+/**
+ * snd_soc_dapm_get_bias_level() - Get current CODEC DAPM bias level
+ * @codec: The CODEC for which to get the DAPM bias level
+ *
+ * Returns: The current DAPM bias level of the CODEC.
+ */
+
+static inline enum snd_soc_bias_level ssm2518_snd_soc_codec_get_bias_level(
+        struct snd_soc_codec *codec)
+{
+        return ssm2518_snd_soc_dapm_get_bias_level(ssm2518_snd_soc_codec_get_dapm(codec));
+}
+ 
 static int ssm2518_set_bias_level(struct snd_soc_codec *codec,
 	enum snd_soc_bias_level level)
 {
@@ -510,7 +638,7 @@
 	case SND_SOC_BIAS_PREPARE:
 		break;
 	case SND_SOC_BIAS_STANDBY:
-		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
+		if (ssm2518_snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF)
 			ret = ssm2518_set_power(ssm2518, true);
 		break;
 	case SND_SOC_BIAS_OFF:
@@ -518,12 +646,11 @@
 		break;
 	}
 
-	if (ret)
-		return ret;
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d ret %d \n", __FUNCTION__,__LINE__, ret);
+  #endif
 
-	codec->dapm.bias_level = level;
-
-	return 0;
+	return ret;
 }
 
 static int ssm2518_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
@@ -620,6 +747,10 @@
 		snd_pcm_hw_constraint_list(substream->runtime, 0,
 				SNDRV_PCM_HW_PARAM_RATE, ssm2518->constraints);
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d ssm2518->constraints == 0x%08X \n", __FUNCTION__,__LINE__, ssm2518->constraints);
+  #endif
+
 	return 0;
 }
 
@@ -652,23 +783,42 @@
 	struct ssm2518 *ssm2518 = snd_soc_codec_get_drvdata(codec);
 	unsigned int val;
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Passed %s %d codec == 0x%08X clk_id == %d \n", __FUNCTION__,__LINE__, codec, clk_id);
+  #endif
+
 	if (clk_id != SSM2518_SYSCLK)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #1, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return -EINVAL;
+	}
 
 	switch (source) {
 	case SSM2518_SYSCLK_SRC_MCLK:
 		val = 0;
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "Passed %s %d SSM2518_SYSCLK_SRC_MCLK \n", __FUNCTION__,__LINE__);
+	  #endif
 		break;
 	case SSM2518_SYSCLK_SRC_BCLK:
 		/* In this case the bitclock is used as the system clock, and
 		 * the bitclock signal needs to be connected to the MCLK pin and
 		 * the BCLK pin is left unconnected */
 		val = SSM2518_POWER1_NO_BCLK;
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Passed %s %d SSM2518_SYSCLK_SRC_BCLK \n", __FUNCTION__,__LINE__);
+	  #endif
 		break;
 	default:
 		return -EINVAL;
 	}
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Frequency == %d, passed %s %d \n", __FUNCTION__,__LINE__, freq);
+  #endif
+
 	switch (freq) {
 	case 0:
 		ssm2518->constraints = NULL;
@@ -728,17 +878,11 @@
 	.num_dapm_routes = ARRAY_SIZE(ssm2518_routes),
 };
 
-static bool ssm2518_register_volatile(struct device *dev, unsigned int reg)
-{
-	return false;
-}
-
 static const struct regmap_config ssm2518_regmap_config = {
 	.val_bits = 8,
 	.reg_bits = 8,
 
 	.max_register = SSM2518_REG_DRC_9,
-	.volatile_reg = ssm2518_register_volatile,
 
 	.cache_type = REGCACHE_RBTREE,
 	.reg_defaults = ssm2518_reg_defaults,
@@ -752,32 +896,78 @@
 	struct ssm2518 *ssm2518;
 	int ret;
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: i2c_client == 0x%08X, i2c_device_id == 0x%08X, passed %s %d \n", __FUNCTION__,__LINE__, freq);
+  #endif
+
 	ssm2518 = devm_kzalloc(&i2c->dev, sizeof(*ssm2518), GFP_KERNEL);
 	if (ssm2518 == NULL)
+	{
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: Error #1, passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 		return -ENOMEM;
+	}
 
-	if (pdata) {
+	if (pdata)
+	{
 		ssm2518->enable_gpio = pdata->enable_gpio;
-	} else if (i2c->dev.of_node) {
+	}
+	else if (i2c->dev.of_node)
+	{
 		ssm2518->enable_gpio = of_get_gpio(i2c->dev.of_node, 0);
-		if (ssm2518->enable_gpio < 0 && ssm2518->enable_gpio != -ENOENT)
+		
+		if ((ssm2518->enable_gpio < 0) && (ssm2518->enable_gpio != -ENOENT))
+		{
+		  #if DEBUG_SSM2518_SW
+			printk(KERN_ALERT "DEBUG: Enable GPIO = %d passed %s %d \n", __FUNCTION__,__LINE__, ssm2518->enable_gpio);
+		  #endif
+		  
 			return ssm2518->enable_gpio;
-	} else {
+		}
+	}
+	else
+	{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Enable GPIO == -1 passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
+	  
 		ssm2518->enable_gpio = -1;
 	}
 
-	if (gpio_is_valid(ssm2518->enable_gpio)) {
+	if (gpio_is_valid(ssm2518->enable_gpio))
+	{
 		ret = devm_gpio_request_one(&i2c->dev, ssm2518->enable_gpio,
 				GPIOF_OUT_INIT_HIGH, "SSM2518 nSD");
 		if (ret)
+		{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Error #2, passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
 			return ret;
+		}
 	}
 
 	i2c_set_clientdata(i2c, ssm2518);
 
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: i2c_set_clientdata passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
+
 	ssm2518->regmap = devm_regmap_init_i2c(i2c, &ssm2518_regmap_config);
+	
 	if (IS_ERR(ssm2518->regmap))
+	{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Error #3, passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
+	  
 		return PTR_ERR(ssm2518->regmap);
+	}
+	
+  #if DEBUG_SSM2518_SW
+    printk(KERN_ALERT "DEBUG: devm_regmap_init_i2c passed %s %d \n", __FUNCTION__,__LINE__);
+  #endif
 
 	/*
 	 * The reset bit is obviously volatile, but we need to be able to cache
@@ -786,23 +976,48 @@
 	 * touch the reset bit just bypass the cache for this operation.
 	 */
 	regcache_cache_bypass(ssm2518->regmap, true);
+	
 	ret = regmap_write(ssm2518->regmap, SSM2518_REG_POWER1,
 			SSM2518_POWER1_RESET);
+			
 	regcache_cache_bypass(ssm2518->regmap, false);
+	
 	if (ret)
+	{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Error #4, passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
 		return ret;
+	}
 
 	ret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER2,
 				SSM2518_POWER2_APWDN, 0x00);
 	if (ret)
+	{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Error #5, passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
 		return ret;
+	}
 
 	ret = ssm2518_set_power(ssm2518, false);
+	
 	if (ret)
+	{
+	  #if DEBUG_SSM2518_SW
+		printk(KERN_ALERT "DEBUG: Error #6, passed %s %d \n", __FUNCTION__,__LINE__);
+	  #endif
 		return ret;
+	}
 
-	return snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,
+	ret = snd_soc_register_codec(&i2c->dev, &ssm2518_codec_driver,
 			&ssm2518_dai, 1);
+			
+  #if DEBUG_SSM2518_SW
+	printk(KERN_ALERT "DEBUG: snd_soc_register_codec() == %d, passed %s %d \n", ret, __FUNCTION__,__LINE__);
+  #endif
+	
+	return ret;
 }
 
 static int ssm2518_i2c_remove(struct i2c_client *client)
@@ -820,7 +1035,6 @@
 static struct i2c_driver ssm2518_driver = {
 	.driver = {
 		.name = "ssm2518",
-		.owner = THIS_MODULE,
 	},
 	.probe = ssm2518_i2c_probe,
 	.remove = ssm2518_i2c_remove,
